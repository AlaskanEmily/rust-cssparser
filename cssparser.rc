#[link(name = "cssparser", vers = "0.1")];
#[crate_type = "lib"];

extern mod std;
mod tokens;
mod tree;


// When reporting these errors to the user, the application is expected
// to show the source filename/URL/location in addition to line and column.
pub struct ParseError {
    message: ~str,
    // TODO: add these:
//    source_line: uint,
//    source_column: uint,
}


#[deriving_eq]
pub enum NumericValue {
    Integer(int),
    // The spec calls this "number".
    // Use "float" instead to reduce term overloading with "number token".
    Float(float),
}


impl NumericValue {
    pure fn to_float(&self) -> float {
        match *self {
            Integer(value) => value as float,
            Float(value) => value,
        }
    }
}


pub pure fn ascii_lower(string: &str) -> ~str {
    // Warning: premature optimization ahead ;)
    // TODO: would it be more efficient to work on bytes,
    // without decoding/re-encoding UTF-8?
    do str::map(string) |c| {
        match c {
            'A'..'Z' => c + ASCII_LOWER_OFFSET,
            _ => c,
        }
    }
}


//  ***********  End of public API  ***********


const ASCII_LOWER_OFFSET: char = 'a' - 'A';

#[test]
fn test_ascii_lower() {
    assert ascii_lower("url()URL()uRl()Ürl") == ~"url()url()url()Ürl";
    // Dotted capital I, Kelvin sign, Sharp S.
    assert ascii_lower("HİKß") == ~"hİKß";
}


const MAX_UNICODE: char = '\U0010FFFF';


// TODO http://dev.w3.org/csswg/css3-syntax/#the-input-byte-stream
// fn decode(input: &[u8], protocol_encoding: &str, link_encoding: &str,
//           document_encoding: &str) -> ~str
// Use empty strings for “no such encoding information”?


// http://dev.w3.org/csswg/css3-syntax/#preprocessing-the-input-stream
pure fn preprocess(input: &str) -> ~str {
    // TODO: Is this faster if done in one pass?
    str::replace(str::replace(str::replace(input,
    "\r\n", "\n"),
    "\r", "\n"),
    "\x00", "\uFFFD")
}


#[test]
fn test_preprocess() {
    assert preprocess("") == ~"";
    assert preprocess("Lorem\r\n\t\x00ipusm\ndoror\uFFFD\r")
        == ~"Lorem\n\t\uFFFDipusm\ndoror\uFFFD\n";
}
